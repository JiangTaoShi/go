##### new 和 make 的区别

```go
值类型是 int、float、string、bool、struct和array，它们直接存储值，分配栈的内存空间，它们被函数调用完之后会释放
引用类型是 slice、map、chan和值类型对应的指针 它们存储是一个地址（或者理解为指针）,指针指向内存中真正存储数据的首地址，内存通常在堆分配，通过GC回收

new 的参数要求传入一个类型，而不是一个值，它会申请该类型的内存大小空间，并初始化为对应的零值，返回该指向类型空间的一个指针
make 也用于内存分配，但它只用于引用对象 slice、map、channel的内存创建，而且返回类型是实例

因为编译的时候会自动内存逃逸处理,不一定分配在哪
```

#####  数组和切片

```go
数组固定长度。数组长度是数组类型的一部分，所以[3]int 和[4]int 是两种不同的数组类型数组需要指定大小，不指定也会根据初始化，自动推算出大小，大小不可改变。数组是通过值传递的

切片可以改变长度。切片是轻量级的数据结构，三个属性，指针，长度，容量不需要指定大小切片是地址传递（引用传递）可以通过数组来初始化，也可以通过内置函数 make()来初始化，初始化的时候 len=cap，然后进行扩容。

数组是值类型，切片是引用类型
```

#####  值传递和地址传递 

```
值传递只会把参数的值复制一份放进对应的函数，两个变量的地址不同，不可相互修改。
地址传递(引用传递)会将变量本身传入对应的函数，在函数中可以对该变量进行值内容的修改。
```

#####   defer 的执行顺序是什么？ defer 的作用和特 点是什么？ 

```go
defer 的作用是：
你只需要在调用普通函数或方法前加上关键字 defer，就完成了 defer 所需要
的语法。当 defer 语句被执行时，跟在 defer 后面的函数会被延迟执行。直到
包含该 defer 语句的函数执行完毕时，defer 后的函数才会被执行，不论包含
defer 语句的函数是通过 return 正常结束，还是由于 panic 导致的异常结束。
你可以在一个函数中执行多条 defer 语句，它们的执行顺序与声明顺序相反。
defer 的常用场景：
defer 语句经常被用于处理成对的操作，如打开、关闭、连接、断开连接、
加锁、释放锁。
通过 defer 机制，不论函数逻辑多复杂，都能保证在任何执行路径下，资
源被释放。
释放资源的 defer 应该直接跟在请求资源的语句后。
```

##### GC垃圾回收方式

```go
标记-清扫
标记-压缩
半空间复制
引用计数
分代GC
并发、增量、准确式三色标记
```

##### GC触发时机

```
主动触发 调用runtime.gc
被动触发 
```

##### 进程

```go
任何语言的并行，到操作系统层面，都是内核线程的并行
同一个线程内的多个线程共享系统资源，进程的创建、销毁、切换比线程大很多
从进程到线程再到协程，其实是一个不断共享，不断减少切换成本的过程
```

##### 协程

```go
轻松创建上百万的协程而不会导致系统资源枯竭、初始分配4K堆栈，随着程序的执行自动增长删除
由Go Runtime负责管理，创建销毁非常小，是用户级的
Go 随着并发的不断增大，耗时是线性增长
非抢占式 由Go Runtime主动交出控制权
```

##### 线程

```go
通常最多不能超过一万个、创建线程时堆栈的大小固定，通常以M为单位
操作系统创建和开销巨大，通常解决办法就是线程池
在系统分配时间片用完后，由CPU强行中断任务并将其调度走，这时需要保存很多信息
```

##### 原子操作

```go
原子操作即是进行过程中不能被中断的操作，针对某个值的原子操作在被进行过程中，CPU绝不会被进行其他针对的操作，原子操作仅由一个独立的CPU指令代表和完成。原子操作是无锁的，常常通过CPU指令直接实现。
原子操作由底层硬件支持，而锁操作由操作系统的调度器实现
```

##### MPG并发模型

```go
M（Machine）对应一个内核线程
P（Processor）虚拟的处理器 
G（Goroutine）
```

##### HTTP面试题

```go


```

#####  详细介绍一下 TCP 的四次挥手机制 

```go
为什么要有 TIME_WAIT 状态？因为客户端最后向服务器发送的确认 ACK 是有可能丢失的，当出现超时，服务端会再次发送 FIN 报文段，如果客户端已经关闭了就收不到了。还有一点是避免新旧连接混杂。
大量 CLOSE_WAIT 表示程序出现了问题，对方的 socket 已经关闭连接，而我方忙于读或写没有及时关闭连接，需要检查代码，特别是释资源的代码，或者是处理请求的线程配置。
```

#####  死锁 

```go
在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲就是两个或多个进程无限期的阻塞、相互等待的一种状态。




```

##### 优雅的启停

```go
不可以关闭现有连接（进程）
新的进程启动并「接管」旧进程
连接要随时响应用户请求，不可以出现拒绝请求的情况
停止的时候，必须处理完既有连接，并且停止接收新的连接。
```

